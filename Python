Задание 1: Изоморфизмы
Реализовать функцию (или тело функции), которая проверяет на изоморфность два слова. Пояснение: строки s и t называются изоморфными, если все вхождения каждого символа строки s можно последовательно заменить другим символом и получить строку t. 
Порядок символов при этом должен сохраняться, а замена — быть уникальной. Так, два разных символа строки s нельзя заменить одним и тем же символом из строки t, а вот одинаковые символы в строке s должны заменяться одним и тем же символом.

# Пример:
s = 'paper' 
t = 'title' 
print(is_isomorphic(s, t))
# Вывод: 
True

Решение

1. Нужно проверить, существует ли биекция (взаимно однозначное отображение, соответствие) между символами s и t:
- один и тот же символ в s всегда переходит в один и тот же символ в t;
- разные символы s не могут перейти в один и тот же символ t

Для этого введу две таблицы соответствий s->t и t->s

2. Код Python:
def is_isomorphic(s: str, t: str) -> bool:
    if len(s) != len(t):
        return False

    s_to_t = {}
    t_to_s = {}

    for cs, ct in zip(s, t):
        # Проверяем соответствие cs -> ct
        if cs in s_to_t:
            if s_to_t[cs] != ct:
                return False
        else:
            s_to_t[cs] = ct

        # Проверяем соответствие ct -> cs 
        if ct in t_to_s:
            if t_to_s[ct] != cs:
                return False
        else:
            t_to_s[ct] = cs

    return True

3. Оценка оптимальности:
Время O(n), где n = len(s) — один проход по строкам. Быстрее асимптотически нельзя, потому что в худшем случае нужно посмотреть каждый символ
Память O(k), где k — число различных символов (в сумме в s и t).
Это тоже оптимально по порядку, ведь чтобы поддерживать согласованное отображение, нужно хранить соответствия хотя бы для встреченных уникальных символов




Задание 2: Натуральная последовательность
Реализовать функцию (или тело функции), которая находит единственное отсутствующее число из последовательности натуральных чисел 1,2,…,n.

# Пример:
nums = [1, 2, 3, 4, 5, 6, 8, 9, 10, 11]
print(missing_number(nums))
# Вывод: 
7

Оценить оптимальность решения по времени и памяти и прикрепить текст кода.

Решение

1. Из условия задачи отсутсвует одно число в последовательности натуральных чисел 1,2,…,n. Буду дейсвтовать через сумму

2. Код Python 

from typing import List

def missing_number(nums: List[int]) -> int:
   
    n = len(nums) + 1
    expected_sum = n * (n + 1) // 2
    actual_sum = sum(nums)
    return expected_sum - actual_sum

3. Оценка оптимальности
Время O(n) - нужно просуммировать массив
Память O(1) дополнительная - используются только несколько переменных.





Задание 3: Факторизация
Реализовать функцию (или тело функции), которая при введении натурального числа n разбивает его на простые множители (представить его в виде простых чисел).

# Пример:
n = 56
print(prime_factors(n))
# Вывод:
[2, 2, 2, 7]

Оценить оптимальность решения по времени и памяти и прикрепить текст кода.

Решение

1. По условию нужно разбить n на простые множители

2. Код Python
from typing import List

def prime_factors(n: int) -> List[int]:
    if n <= 1:
        return []

    factors: List[int] = []

    # Выносим 2
    while n % 2 == 0:
        factors.append(2)
        n //= 2

    # Дальше проверяем только нечётные делители
    d = 3
    while d * d <= n:
        while n % d == 0:
            factors.append(d)
            n //= d
        d += 2

    # Если осталось число > 1, оно простое
    if n > 1:
        factors.append(n)

    return factors

3. Оценка оптимальности
Время
- Когда n - простое, перебор делителей до √n, то есть O(√n).
- Память O(k) на список ответа, где k - количество простых множителей с учётом повторов. Дополнительная память помимо результата - O(1)
